# What is JSFuck?
JSFuck is a subset of Javascript that uses only the six characters "[]()+!". It turns out that this is sufficient to express anything that can be expressed in regular Javascript, at least in most Javascript environments. The name JSFuck is derived from [Brainfuck](https://en.wikipedia.org/wiki/Brainfuck), an esoteric programming language with a similarly limited set of valid characters that JSFuck resembles.

# How does the JSFuck Transpiler work?
This transpiler takes ordinary Javascript code and outputs JSFuck code that is functionally equivalent.

To get started, we first take advantage of Javascript's type-casting to obtain some primitive values. With the given symbols, we can express the empty array with `[]`. Next, with the exclamation mark we can write `![]` which evaluates to false. This works because `!` is the unary boolean negation operator which will cast its argument to a boolean value. In this case, we apply it to `[]` which is implictly casted to `true`. Similarly, we can write `!![]` which evaluates to true. This gives us booleans. We can next add booleans to produce numbers; `false` is casted to `0` and `true` is casted to 1. Thus, the number 3 can be written as `!![]+!![]+!![]`. By adding a sufficient number of `!![]`'s we are able to produce any positive integer we desire. Finally, we are able to obtain strings by adding the empty array. Thus, for example, `![]+[]` will evaluate to the string `"false"`. Finally, we can write `[][[]]` to obtain undefined by attempting to index into the empty array by itself.

We now have all the basic building blocks at our disposal. We are able to produce the empty array, the boolean values `true` and `false`, all positive integers, the string representation of any value, and `undefined`. The next step is to call some methods on the objects we've produced. Methods can be called by indexing into the object by the method name, as a string. For example, `"hello world"["search"]("h")` would call the `search()` method on the the `"hello world"` string with the argument `"h"`. To call a method, we first need to figure out a way to produce the method name as a string. With what we have so far, we can easily produce the strings `"true"`, `"false"`, and `"undefined"`. By indexing into these strings we can obtain their individual letters which we then concatenate with the `+` operator to obtain any string that contain only the letters found in "true", "false", and "undefined". This turns out to be just enough to bootstrap us to obtain more letters so that we can call more methods.

We convert the method `[]["fill"]` and into a string to get `function fill() { [native code] }` which gets us some more characters we can use. We can then get the method `[]["fill"]["constructor"]` which produces the Function constructor. The Function constructor in Javascript takes in a string and returns an anonymous function whose body is the string.

At this point it's clear on a high level how to finish writing the transpiler. We simply need to figure out how to encode any ASCII character using the characters "[]()+!" and then pass the encoded Javascript source code to the Function constructor and then execute the anonymous function returned. The final challenge is figuring out how to express an arbitrary ASCII character using "[]()+!". We can do this with String.fromCharCode() which takes in the numerical ASCII value and spits out the character with that ASCII value. The remainder of the transpiler is figuring out how to produce the letters in "fromCharCode" so that we can call it.
